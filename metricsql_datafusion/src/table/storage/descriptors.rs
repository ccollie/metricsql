// Copyright 2023 Greptime Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::fmt;

use serde::{Deserialize, Serialize};

/// Id of column. Unique in each region.
pub type ColumnId = u32;
/// Group number of one region. Unique in each region.
pub type RegionGroup = u8;
/// Sequence number of region inside one table. Unique in each table.
/// The first 8 bits are preserved for [RegionGroup].
pub type RegionSeq = u32;
/// Id of regions under the same table. Unique in each table.
/// Is composed by [RegionGroup] and [RegionSeq].
pub type RegionNumber = u32;
/// Id of table. Universal unique.
pub type TableId = u32;

const REGION_GROUP_MASK: u32 = 0b1111_1111 << 24;
const REGION_SEQ_MASK: u32 = (0b1 << 24) - 1;

/// The max valid region sequence number.
pub const MAX_REGION_SEQ: u32 = REGION_SEQ_MASK;

/// Id of the region. It's generated by concatenating table id, region group and region number.
///
/// ```plaintext
/// 63                                  31         23                  0
/// ┌────────────────────────────────────┬──────────┬──────────────────┐
/// │          Table Id(32)              │ Group(8) │   Sequence(24)   │
/// └────────────────────────────────────┴──────────┴──────────────────┘
///                                         Region Number(32)
/// ```
#[derive(Default, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct RegionId(u64);

impl RegionId {
    /// Construct a new [RegionId] from table id and region number.
    pub const fn new(table_id: TableId, region_number: RegionNumber) -> RegionId {
        RegionId(((table_id as u64) << 32) | region_number as u64)
    }

    /// Returns the table id of the region.
    pub const fn table_id(&self) -> TableId {
        (self.0 >> 32) as TableId
    }

    /// Returns the region number of the region.
    pub const fn region_number(&self) -> RegionNumber {
        self.0 as RegionNumber
    }

    /// Returns the group number of the region
    pub const fn region_group(&self) -> RegionGroup {
        ((self.region_number() & REGION_GROUP_MASK) >> 24) as RegionGroup
    }

    /// Return the sequence number of the region
    pub const fn region_sequence(&self) -> RegionSeq {
        self.region_number() & REGION_SEQ_MASK
    }

    /// Returns the region id as u64.
    pub const fn as_u64(&self) -> u64 {
        self.0
    }

    /// Construct a new [RegionId] from u64.
    pub const fn from_u64(id: u64) -> RegionId {
        RegionId(id)
    }

    /// Construct a new [RegionId] from table id, region group and region sequence.
    pub const fn with_group_and_seq(
        table_id: TableId,
        group: RegionGroup,
        seq: RegionSeq,
    ) -> RegionId {
        RegionId(
            ((table_id as u64) << 32)
                | ((group as u32) << 24) as u64
                | (seq & REGION_SEQ_MASK) as u64,
        )
    }
}

impl fmt::Debug for RegionId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}({}, {})",
            self.0,
            self.table_id(),
            self.region_number()
        )
    }
}

impl fmt::Display for RegionId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl From<u64> for RegionId {
    fn from(region_id: u64) -> RegionId {
        RegionId::from_u64(region_id)
    }
}

impl From<RegionId> for u64 {
    fn from(region_id: RegionId) -> u64 {
        region_id.as_u64()
    }
}

impl PartialEq<u64> for RegionId {
    fn eq(&self, other: &u64) -> bool {
        self.0 == *other
    }
}

impl PartialEq<RegionId> for u64 {
    fn eq(&self, other: &RegionId) -> bool {
        *self == other.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_region_id_to_json() {
        let region_id = RegionId::from(4294967297);
        let json = serde_json::to_string(&region_id).unwrap();
        assert_eq!("4294967297", json);

        let parsed: RegionId = serde_json::from_str(&json).unwrap();
        assert_eq!(region_id, parsed);
    }

    #[test]
    fn test_invalid_large_region_sequence() {
        // region sequence larger than `MAX_REGION_SEQ` will be masked into valid range
        let region_id = RegionId::with_group_and_seq(111, 222, u32::MAX);
        assert_eq!(MAX_REGION_SEQ, region_id.region_sequence());
    }
}